{"ast":null,"code":"import _classCallCheck from \"/Users/pravin/workspace/code-world/cc-terminal/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/pravin/workspace/code-world/cc-terminal/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Observable, Subject } from 'rxjs';\nimport { filter, map, takeUntil } from 'rxjs/operators';\nimport cloneDeep from 'lodash.clonedeep';\nimport * as i0 from \"@angular/core\";\nexport var CcTerminalService = /*#__PURE__*/(function () {\n  var CcTerminalService = /*#__PURE__*/function () {\n    function CcTerminalService() {\n      _classCallCheck(this, CcTerminalService);\n\n      this.ngUnsubscribe = new Subject(); // https://stackoverflow.com/questions/38008334/angular-rxjs-when-should-i-unsubscribe-from-subscription/41177163#41177163\n\n      this.event = new Subject();\n      this.readyStore();\n    }\n\n    _createClass(CcTerminalService, [{\n      key: \"fetch\",\n      value: function fetch(url) {\n        return Observable.create(function (observer) {\n          // angular http lib does not support arrayBuffer hence XMLHTTP\n          var req = new XMLHttpRequest();\n          req.open('get', url, true);\n          req.responseType = 'arraybuffer';\n\n          req.onreadystatechange = function () {\n            if (req.readyState === 4 && req.status === 200) {\n              observer.next(req.response);\n              observer.complete();\n            }\n          };\n\n          req.send();\n        });\n      } // calls the next event with listener id on listening component and data to send\n\n    }, {\n      key: \"broadcast\",\n      value: function broadcast(key, data) {\n        this.event.next({\n          key: key,\n          data: data\n        });\n      }\n      /**\n       * @description - This function will register to execute the store whenever store is ready.\n       */\n\n    }, {\n      key: \"readyStore\",\n      value: function readyStore() {\n        var _this = this;\n\n        this.on('store-ready').subscribe(function (_store) {\n          _this.store = _store;\n\n          _this.store.state$.subscribe(function (state) {\n            console.log('StoreReady: In Service:', state);\n          });\n        });\n      } // filters through active observers and maps data to a matching observer\n\n    }, {\n      key: \"on\",\n      value: function on(key) {\n        return this.event.asObservable().pipe(filter(function (event) {\n          return event.key === key;\n        }), map(function (event) {\n          return event.data;\n        }));\n      }\n      /**\n       * @description - Get the Current prompt\n       */\n\n    }, {\n      key: \"getPrompt\",\n      value: function getPrompt() {\n        return this.prompt;\n      }\n      /**\n       * @description - Get the Current store\n       */\n\n    }, {\n      key: \"getStore\",\n      value: function getStore() {\n        console.log('here');\n        return this.store;\n      }\n    }, {\n      key: \"initPrompt\",\n      value: function initPrompt(config) {\n        var _this2 = this;\n\n        this.prompt = {};\n\n        var _user, _path, _userPathSeparator, _promptEnd;\n\n        config = config ? config.promptConfiguration : null;\n\n        var build = function build() {\n          _this2.prompt.text = _user + _userPathSeparator + _path + _promptEnd;\n        };\n\n        this.prompt.reset = function () {\n          _user = config && config.user != null ? config.user || '' : 'anon';\n          _path = config && config.path != null ? config.path || '' : '\\\\';\n          _userPathSeparator = config && config.separator != null ? config.separator || '' : '@';\n          _promptEnd = config && config.end != null ? config.end || '' : ':>';\n          build();\n        };\n\n        this.prompt.text = '';\n        this.prompt.reset();\n        return this.prompt;\n      }\n      /**\n       * @description - This function will help you to interpret your commands.\n       * @param cmd - command\n       */\n\n    }, {\n      key: \"interpret\",\n      value: function interpret(cmd) {\n        var _this3 = this;\n\n        var prompt = this.getPrompt(); // this.store.state$.subscribe(state => { console.log(state); });\n\n        var command = (cmd.command || '').split(' ');\n        var _command = null;\n        this.store.state$.pipe(takeUntil(this.ngUnsubscribe)).subscribe(function (state) {\n          _command = cloneDeep(state.commands.filter( // Remove the reference of command by making copy, to avoid modifying the command state\n          function (item) {\n            return item.name === command[0];\n          })[0] || null);\n        });\n\n        if (_command && _command.name) {\n          if (_command.callback && typeof _command.callback === 'function') {\n            _command.callback();\n          }\n\n          switch (_command.name) {\n            case 'help':\n              _command.details.result = _command.details.result.map(function (_result) {\n                if (_result && _result.text && typeof _result.text === 'function') {\n                  var text = _result.text(_this3.store.state.commands.map(function (c) {\n                    return c.name;\n                  }));\n\n                  return Object.assign(Object.assign({}, _result), {\n                    text: text\n                  });\n                } else {\n                  return _result;\n                }\n              });\n              break;\n\n            default:\n              _command.details.result = _command.details.result.map(function (_result) {\n                if (_result && _result.text && typeof _result.text === 'function') {\n                  var text = _result.text().toString();\n\n                  return Object.assign(Object.assign({}, _result), {\n                    text: text\n                  });\n                } else {\n                  return _result;\n                }\n              });\n          }\n\n          _command.details.result.splice(0, 0, {\n            text: prompt.text + cmd.command\n          });\n\n          console.log('Final:', _command);\n          this.broadcast('terminal-output', _command);\n        } else {\n          var result = '';\n\n          try {\n            result = eval(cmd.command); // eval.call(null, cmd.command);\n\n            if (result !== undefined) {\n              this.broadcast('terminal-output', {\n                details: {\n                  output: true,\n                  result: [{\n                    text: prompt.text + cmd.command\n                  }, {\n                    text: '' + result\n                  }],\n                  breakLine: true\n                }\n              });\n            }\n          } catch (e) {\n            this.broadcast('terminal-output', {\n              details: {\n                output: true,\n                result: [{\n                  text: prompt.text + cmd.command\n                }, {\n                  text: '' + e,\n                  css: {\n                    color: 'red'\n                  }\n                }],\n                breakLine: true\n              }\n            });\n          }\n        }\n        /**\n         * @description - Regex for exact match command\n         *   note: we can add this in constants\n         *  TODO: We can design the exact match regex based command also.\n         */\n\n\n        var regex = {\n          alert: /^alert$/\n        }; // Example of how to work with regex based command\n        // else if (regex.alert.test(command[0])) {\n        // this.broadcast('terminal-output', {\n        //   details: {\n        //   output: true,\n        //   result: [\n        //      { text: prompt.text + cmd.command, },\n        //      { text: '' + e, css: { color: 'red' } }],\n        //     breakLine: true,\n        //   }\n        // });\n        //   command.splice(0, 1); // Remove command from command string\n        //   alert(command.join(' '));\n        //   console.log(command);\n        // }\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        // Clear Storage allocation of memory.\n        this.ngUnsubscribe.next();\n        this.ngUnsubscribe.complete();\n      }\n    }]);\n\n    return CcTerminalService;\n  }();\n\n  CcTerminalService.ɵfac = function CcTerminalService_Factory(t) {\n    return new (t || CcTerminalService)();\n  };\n\n  CcTerminalService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: CcTerminalService,\n    factory: CcTerminalService.ɵfac,\n    providedIn: 'root'\n  });\n  return CcTerminalService;\n})();","map":null,"metadata":{},"sourceType":"module"}